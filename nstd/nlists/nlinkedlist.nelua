## if not NLINKEDLIST then --[
   ## NLINKEDLIST = true

   ## cinclude '<stdlib.h>'
   local function malloc (size: csize): pointer <cimport 'malloc', nodecl> end
   local function free (ptr: pointer): void <cimport 'free', nodecl> end

   local nLinkedListNode = @record {
      data_ptr: pointer, -- pointer(any)
      next_ptr: pointer,  -- pointer(nLinkedListNode)
      prev_ptr: pointer  -- pointer(nLinkedListNode)
   }

   function nLinkedListNode.new(ptr: pointer): pointer(nLinkedListNode)
      local newnode: pointer(nLinkedListNode) = (@nLinkedListNode*)(malloc(#@nLinkedListNode))
      $newnode = (@nLinkedListNode){data_ptr = ptr, next_ptr = nilptr, prev_ptr = nilptr}
      return newnode
   end

   global  nLinkedList = @record {
      head: pointer(nLinkedListNode),
      tail_end: pointer(nLinkedListNode),
      last_used: pointer(nLinkedListNode),
      last_used_idx: uinteger,
      length: uinteger
   }

   function nLinkedList.new(): nLinkedList
      local newLL = (@nLinkedList){head = nilptr, tail_end = nilptr, last_used = nilptr, last_used_idx = 0_u, length = 0_u}
      return newLL
   end

   function nLinkedList:contains(idx: uinteger): boolean
      return idx < self.length
   end
   
   local function step_forward(node_ptr: pointer(nLinkedListNode), count: uinteger): pointer(nLinkedListNode)
      for _ = 1_u, count do
         local node: nLinkedListNode = $node_ptr
         node_ptr = (@nLinkedListNode*)(node.next_ptr)
      end
      return node_ptr
   end
   
   local function step_backward(node_ptr: pointer(nLinkedListNode), count: uinteger): pointer(nLinkedListNode)
      for _ = 1_u, count do
         local node: nLinkedListNode = $node_ptr
         node_ptr = (@nLinkedListNode*)(node.prev_ptr)
      end
      return node_ptr
   end
   
   local function find_from_head(head_ptr: pointer(nLinkedListNode), index: uinteger): pointer(nLinkedListNode)
      return step_forward(head_ptr, index)
   end
   
   local function find_from_tail_end(tail_end_ptr: pointer(nLinkedListNode), index: uinteger, linkedlist_len: uinteger): pointer(nLinkedListNode)
      return step_backward(tail_end_ptr, linkedlist_len - index - 1)
   end
   
   local function find_forward_from_last_used(lastnode_ptr: pointer(nLinkedListNode), index: uinteger, last_used_idx: uinteger): pointer(nLinkedListNode)
      return step_forward(lastnode_ptr, index - last_used_idx)
   end
   
   local function find_backward_from_last_used(lastnode_ptr: pointer(nLinkedListNode), index: uinteger, last_used_idx: uinteger): pointer(nLinkedListNode)
      return step_backward(lastnode_ptr, last_used_idx - index)
   end
   
   -- returns previous node and indexed node
   local function get_nodes(linkedlist_ptr: pointer(nLinkedList), index: uinteger): array(pointer(nLinkedListNode), 2)
      local linkedlist = $linkedlist_ptr

      assert(
         index == 0_u or index <= linkedlist.length,
         "1st argument 'index' should be = 0 or <= of 'length' of the list"
      )

      --print('get nodes index, length, last used', index, linkedlist.length, linkedlist.last_used_idx)

      -- optimization for first and last nodes
      if index == 0 then -- is the first node
         local prev_node_ptr: pointer(nLinkedListNode) = nilptr
         local node_ptr: pointer(nLinkedListNode) = linkedlist.head

         local result: array(pointer(nLinkedListNode), 2) = {prev_node_ptr, node_ptr}
         return result
      elseif index == linkedlist.length - 1 then -- is the last node
         local node_ptr: pointer(nLinkedListNode) = linkedlist.tail_end

         local node: nLinkedListNode = $node_ptr
         local prev_node_ptr: pointer(nLinkedListNode) = (@nLinkedListNode*)(node.prev_ptr)

         local result: array(pointer(nLinkedListNode), 2) = {prev_node_ptr, node_ptr}
         return result
      end

      -- search for the nodes, and search using the last used as optimization
      local node_ptr: pointer(nLinkedListNode) = linkedlist.last_used
      local node: nLinkedListNode = $node_ptr
      local prev_node_ptr: pointer(nLinkedListNode);

      if index == linkedlist.last_used_idx then -- the node is the last used
         prev_node_ptr = (@nLinkedListNode*)(node.prev_ptr)
         local result: array(pointer(nLinkedListNode), 2) = {prev_node_ptr, node_ptr}
         return result
      elseif index > linkedlist.last_used_idx then -- the node is after the last used
         local distance_from_tail_end = linkedlist.length - index - 1
         local distance_from_last_used = index - linkedlist.last_used_idx
         
         if distance_from_tail_end <= distance_from_last_used then
            node_ptr = find_from_tail_end(linkedlist.tail_end, index, linkedlist.length)
            prev_node_ptr = (@nLinkedListNode*)(($node_ptr).prev_ptr)
         else
            node_ptr = find_forward_from_last_used(node_ptr, index, linkedlist.last_used_idx)
            prev_node_ptr = (@nLinkedListNode*)(($node_ptr).prev_ptr)
         end
         
         local result: array(pointer(nLinkedListNode), 2) = {prev_node_ptr, node_ptr}
         return result
      else -- the node is before the last used
         local distance_from_head = index
         local distance_from_last_used = linkedlist.last_used_idx - index
         
         if distance_from_head <= distance_from_last_used then
            node_ptr = find_from_head(linkedlist.head, index)
            prev_node_ptr = (@nLinkedListNode*)(($node_ptr).prev_ptr)
         else
            node_ptr = find_backward_from_last_used(node_ptr, index, linkedlist.last_used_idx)
            prev_node_ptr = (@nLinkedListNode*)(($node_ptr).prev_ptr)
         end

         local result: array(pointer(nLinkedListNode), 2) = {prev_node_ptr, node_ptr}
         return result
      end

   end

   function nLinkedList:insert(index: uinteger, size: csize): pointer
      assert(index <= self.length, "1st argument 'index' should be <= of 'length' of list")

      local nodedata_ptr = malloc(size)
      local newnode_ptr: pointer(nLinkedListNode) = nLinkedListNode.new(nodedata_ptr)
      local newnode: nLinkedListNode = $newnode_ptr

      if index == 0 and self.length == 0 then -- insert at the begining
         self.head = newnode_ptr
         self.tail_end = newnode_ptr
      elseif index == self.length then -- insert at the end
         local last_node: nLinkedListNode = $self.tail_end
         last_node.next_ptr = newnode_ptr
         newnode.prev_ptr = self.tail_end
         $self.tail_end = last_node

         self.tail_end = newnode_ptr -- change to the new last node
      else
         local nodes = get_nodes(self, index)
         local prev_node_ptr: pointer(nLinkedListNode) = nodes[0]
         local node_ptr: pointer(nLinkedListNode) = nodes[1]

         if index > 0 then -- is not the first
            local prev_node: nLinkedListNode = $prev_node_ptr
            prev_node.next_ptr = newnode_ptr
            newnode.prev_ptr = prev_node_ptr
            $prev_node_ptr = prev_node
         end

         if index < self.length-1 then -- is not the last
            newnode.next_ptr = node_ptr
         end
      end

      $newnode_ptr = newnode
      self.last_used = newnode_ptr
      self.last_used_idx = index
      self.length = self.length + 1

      return nodedata_ptr
   end

   function nLinkedList:remove(index: uinteger)
      assert(index < self.length, "1st argument 'index' should be < of 'length' of list")

      local nodes = get_nodes(self, index)

      if index > 0 then
         local prev_node_ptr: pointer(nLinkedListNode) = nodes[0]
         local node_ptr: pointer(nLinkedListNode) = nodes[1]

         local prev_node = $prev_node_ptr
         local node = $node_ptr

         prev_node.next_ptr = node.next_ptr
         $prev_node_ptr = prev_node
         self.last_used = prev_node_ptr
         self.last_used_idx = index

         free(node.data_ptr)
         free(node_ptr)
      else
         local node_ptr: pointer(nLinkedListNode) = nodes[1]
         local node = $node_ptr

         self.head = (@nLinkedListNode*)(node.next_ptr)
         self.last_used = self.head
         self.last_used_idx = index

         free(node.data_ptr)
         free(node_ptr)
      end

      self.length = self.length - 1
   end

   function nLinkedList:push(size: csize): pointer
      local ptr = self:insert(self.length, size)
      return ptr
   end

   function nLinkedList:pop()
      self:remove(self.length - 1)
   end

   function nLinkedList:clear()
      for i = 0_u, < self.length do
         self:remove(0_u)
      end
   end

   function nLinkedList:get_data_ptr(index: uinteger): pointer
      --print ('get data ptr', index , self.last_used_idx)
      assert(index < self.length, "1st argument 'index' should be < of 'length' of list")

      local nodes = get_nodes(self, index)
      local node_ptr: pointer(nLinkedListNode) = nodes[1]
      local node: nLinkedListNode = $node_ptr

      self.last_used = node_ptr
      self.last_used_idx = index
      --print ('after get data ptr', self.last_used_idx)

      return node.data_ptr
   end

## end --]

## if false then -- if (should test) then [
   do
      local Person = @record {name: string, age: uinteger}
      local mylist = nLinkedList.new()

      -- Brazilian placeholder names from
      -- pt.wikipedia.org/wiki/Fulano
      local names: array(string , 3) = {"Fulano", "Fulana", "ZeDaSilva"}
      local ages: array(uinteger, 3) = {20      , 22      , 46         }

      print 'test inserting'
      local first_person_ptr = (@Person*)(mylist:push(#@Person))
      $first_person_ptr = (@Person){name = names[0], age = ages[0]}

      for i = 1_u, < (@uinteger)(#names) do
         local person_ptr = (@Person*)(mylist:insert(i, #@Person))
         $person_ptr = (@Person){name = names[i], age = ages[i]}
      end

      print 'test comparing'
      assert((@uinteger)(#names) == mylist.length, 'lengths are different')
      for i = 0_u, < mylist.length do
         local person_ptr = (@Person*)(mylist:get_data_ptr(i))
         local person: Person = $person_ptr

         assert(person.name == names[i])
         assert(person.age == ages[i])
      end

      print 'test removing'
      mylist:remove(1_u)

      print 'test comparing after remove'
      for i = 0_u, < mylist.length do
         local person_ptr = (@Person*)(mylist:get_data_ptr(i))
         local person: Person = $person_ptr

         if i < 1_u then
            assert(person.name == names[i])
            assert(person.age == ages[i])
         else
            assert(person.name == names[i+1])
            assert(person.age == ages[i+1])
         end
      end

      local otherlist: nLinkedList = mylist
      assert(otherlist.length == mylist.length, 'list copy length is different from original')
      for i = 0_u, < otherlist.length do
         local o_ptr = (@Person*)(otherlist:get_data_ptr(i))
         local m_ptr = (@Person*)(mylist:get_data_ptr(i))

         local o_vl: Person = $o_ptr
         local m_vl: Person = $m_ptr

         assert(o_vl.name == m_vl.name, 'list copy name is different from original')
         assert(o_vl.age == m_vl.age, 'list copy age is different from original')
      end

      local function testFn (argvl: nLinkedList, mylistptr: pointer(nLinkedList))
         local mylist: nLinkedList = $mylistptr
         assert(argvl.length == (mylist).length, 'list copy length is different from original')
         for i = 0_u, < argvl.length do
            local o_ptr = (@Person*)(argvl:get_data_ptr(i))
            local m_ptr = (@Person*)((mylist):get_data_ptr(i))

            local o_vl: Person = $o_ptr
            local m_vl: Person = $m_ptr

            assert(o_vl.name == m_vl.name, 'list copy name is different from original')
            assert(o_vl.age == m_vl.age, 'list copy age is different from original')
         end
      end

      local argtest: nLinkedList = mylist
      testFn(argtest, &mylist)
   end



   print 'test succeed'
## end --]
