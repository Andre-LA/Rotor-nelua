## local generated_optionals = {}
## function generate_optional(tyname)
   ## if generated_optionals[tyname] then return end
   ## generated_optionals[tyname] = true
   ## local opname = 'Opt_' .. tyname

   global #(opname)# = @record{
      value: #(tyname)#,
      not_nil: boolean
   }

   function #(opname)#:can_get_value() : boolean
      return self.not_nil
   end

   function #(opname)#:get_value(): #(tyname)#
      assert(self:can_get_value(), 'assert error on a optional: cannot get the value because is considered as nil')
      return self.value
   end

   function #(opname)#:set_value(newvalue: #(tyname)#)
      self.value = newvalue
      self.not_nil = true
   end

   function #(opname)#:set_nil()
      local resetvalue: #(tyname)#
      self.value = resetvalue
      self.not_nil = false
   end
## end

## local SHOULDTEST = false
## if SHOULDTEST then
   ## generate_optional('uinteger')
   local x: Opt_uinteger

   assert(x.value == 0 and (not x.not_nil), 'test #1 error: x should be {value = 0, not_nil = false}')
   assert(not x:can_get_value(), 'test #2 error: x:can_get_value() should return false')

   -- this will result in a runtime error, I don't know how to test this
   --local y = x:get_value()

   x:set_value(10)

   assert(x.value == 10 and x.not_nil, 'test #3 error: x should be {value = 10, not_nil = true}')
   assert(x.value == x:get_value(), 'test #4 error: x:get_value should returns the x\'s value')
   assert(x:can_get_value(), 'test #5 error: x:can_get_value() should return true')
## end
