## if not STORAGE_ALREADY_REQUIRED then
   ## STORAGE_ALREADY_REQUIRED = true

   require 'buildstatus'
   ## buildstatus.open('requiring rotor.storage')

   require ('rotor.generational_index')
   require ('rotor.optionals')
   require ('rotor.optionals.uinteger')
   require ('rotor.optionals.pointer')
   require ('nstd.nlists.nlinkedlist')

   global Storage = @record{
      next_free_ids: nLinkedList, -- nLinkedList(GenerationalIndex)
      entries: nLinkedList, -- nLinkedList(pointer),
      generations: nLinkedList, -- nLinkedList(Opt_uinteger),
      len: uinteger
   }

   local function is_valid_entry(storage_ptr: pointer(Storage), gen_idx: GenerationalIndex): boolean
      local storage = $storage_ptr
      local genvalue_ptr = (@Opt_uinteger*)(storage.generations:get_data_ptr(gen_idx.index))
      local genvalue: Opt_uinteger = $genvalue_ptr

      if not genvalue:can_get_value() then
         return false
      elseif gen_idx.generation ~= genvalue:get_value() then
         return false
      end
      return true
   end

   function Storage.new(): Storage
      local newstorage: Storage;
      local gen_idx_ptr = (@GenerationalIndex*)(newstorage.next_free_ids:push(#@GenerationalIndex))
      $gen_idx_ptr = GenerationalIndex.new(0, 0)
      return newstorage
   end


   function Storage:new_entry(entry_size: csize): (pointer, GenerationalIndex)
      local last_index = self.next_free_ids.length - 1
      local last_free_id_ptr = (@GenerationalIndex*)(self.next_free_ids:get_data_ptr(last_index))
      local last_free_id = $last_free_id_ptr

      if self.entries:contains(last_free_id.index) then
         self.entries:remove(last_free_id.index)
      end

      local new_entry_ptr = self.entries:insert(last_free_id.index, entry_size)

      local gennewvalue: Opt_uinteger;
      gennewvalue:set_value(last_free_id.generation)

      if self.generations:contains(last_free_id.index) then
         self.generations:remove(last_free_id.index)
      end

      local gen_set_ptr = (@Opt_uinteger*)(self.generations:insert(last_free_id.index, #@Opt_uinteger))
      $gen_set_ptr = gennewvalue

      local new_id = GenerationalIndex.new(last_free_id.index, last_free_id.generation)

      if last_free_id.index >= self.len then
         self.len = last_free_id.index
         last_free_id.index = last_free_id.index + 1
         last_free_id.generation = 0
      else
         self.next_free_ids:pop()
      end

      $last_free_id_ptr = last_free_id

      -- return a copy of the gen_idx of this new entry
      return new_entry_ptr, new_id
   end

   function Storage:get_entry(gen_idx: GenerationalIndex): Opt_pointer
      local result: Opt_pointer

      if not is_valid_entry(self, gen_idx) then
         return result
      end

      local entry_ptr: pointer = self.entries:get_data_ptr(gen_idx.index)
      result:set_value(entry_ptr)

      return result
   end

   function Storage:remove_entry(gen_idx: GenerationalIndex): boolean
      if not is_valid_entry(self, gen_idx) then
         return false
      end

      if self.entries:contains(gen_idx.index) then
         self.entries:remove(gen_idx.index)
      end

      local entry_set_gptr = self.entries:insert(gen_idx.index, #@pointer)
      local entry_set_ptr = (@pointer*)(entry_set_gptr)
      $entry_set_ptr = nilptr

      local gennewvalue_ptr = (@Opt_uinteger*)(self.generations:get_data_ptr(gen_idx.index))
      local gennewvalue = $gennewvalue_ptr
      gennewvalue:set_nil()
      $gennewvalue_ptr = gennewvalue

      if gen_idx.index == self.len then
         local last_i = 0_u
         for i=0_u, < self.len do
            local genvalue_ptr = (@Opt_uinteger*)(self.generations:get_data_ptr(i))
            local genvalue = $genvalue_ptr
            if genvalue:can_get_value() then
               last_i = i
            end
         end
         self.len = last_i
      end

      local next_free_id_ptr = (@GenerationalIndex*)(self.next_free_ids:push(#@GenerationalIndex))
      $next_free_id_ptr = GenerationalIndex.new(gen_idx.index, gen_idx.generation + 1)

      return true
   end

--   Iterators are NYI feature",
--   function " .. storagetypename .. ".iterate_entries(storage)",
--      local i, entries_len, entry_id = 0, storage.len, new_id(0, 0)",
--
--      return function ()",
--         local ok_entry;",
--
--         while ok_entry == nil and i < entries_len do",
--            i = i + 1",
--            entry_id.index, entry_id.generation = i, (storage.generations[i] or -1)",
--            ok_entry = " .. storagetypename .. ".get_entry(storage, entry_id)",
--         end",
--
--         return ok_entry, entry_id",
--      end",
--   end",

   ## buildstatus.close('rotor.storage required')
## end

## if false then --[
   local Teste = @record {x: number, y: number}
   function Teste:__tostring() print("Teste {x = ", self.x, ", y = ", self.y, "}") end

   print 'NEW'
   local storage_test = Storage.new()

   print 'NEW ENTRY'
   local new_entry_ptr, new_entry_id = storage_test:new_entry(#@Teste)
   local new_entry_Tptr = (@Teste*)(new_entry_ptr)
   $new_entry_Tptr = (@Teste){x = 777, y = 1333}

   print 'GET ENTRY'
   local possible_entry_ptr = storage_test:get_entry(new_entry_id)
   assert(possible_entry_ptr:can_get_value(), 'test error: cannot get value')

   local entry_ptr = (@Teste*)(possible_entry_ptr:get_value())
   local entry: Teste = $entry_ptr

   entry:__tostring()
   print 'storage test succeed'
   --]]
## end --]
