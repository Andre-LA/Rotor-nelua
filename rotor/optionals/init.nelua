##[[
local function generate_optionaltype_code(typename, dependencies)
   local opttypename = "Opt_" .. typename
   buildstatus.open ('generating ' .. opttypename)

   local code_lines = {
      "-- generated by rotor.optionals",
      "   require 'buildstatus'",
      "   ## buildstatus.print('requiring optionals." .. typename .. "')",
      "",
      "   global " .. opttypename .. " = @record{",
      "      value: " .. typename .. ",",
      "      not_nil: boolean",
      "   }",
      "",
      "   function " .. opttypename .. ":can_get_value() : boolean",
      "      return self.not_nil",
      "   end",
      "   function " .. opttypename .. ":get_value(): " .. typename,
      "      assert(self:can_get_value(), 'assert error on a optional: cannot get the value because is considered as nil')",
      "      return self.value",
      "   end",
      "   function " .. opttypename .. ":set_value(newvalue: " .. typename .. ")",
      "      self.value = newvalue",
      "      self.not_nil = true",
      "   end",
      "   function " .. opttypename .. ":set_nil()",
      "      local resetvalue: " .. typename.. ";",
      "      self.value = resetvalue",
      "      self.not_nil = false",
      "   end",
      "",
      "   ## buildstatus.print('optionals." .. typename .. " required')",
      ""
   }

   -- insert dependencies in the 5th line
   if dependencies then
      for i = 1, #dependencies do
         table.insert(code_lines, 4+i, "   require '" .. dependencies[i] .. "'")
      end
      table.insert(code_lines, 5, "") -- just extra line before requires
   end

   local codestr = table.concat(code_lines, '\n')
   local filename = 'rotor/optionals/' .. typename .. '.nelua'

   local codefile, err = io.open(filename, 'w')
   if codefile then
      buildstatus.print ('writing file in ' .. filename)
      codefile:write(codestr)
      codefile:close()
   else
      buildstatus.close (opttypename .. " not generated")
      error(err)
   end

   buildstatus.close (opttypename .. " generated")
end
]]

## local already_generated = {}
##[[
_optionals = {
   generate_optional = function(typename, dependencies)
      if not already_generated[typename] then
         if dependencies then
            assert(type(dependencies) == 'table', 'generate_optional assert error: 2nd argument should be a table of strings or nil')
         end
         generate_optionaltype_code(typename, dependencies)
         already_generated[typename] = true
      end
   end
}
]]

   require 'buildstatus'
   ## buildstatus.open 'requiring optionals'

   ## _optionals.generate_optional("boolean")
   ## _optionals.generate_optional("integer")
   ## _optionals.generate_optional("uinteger")
   ## _optionals.generate_optional("pointer")

   --## _optionals.generate_optional("string")
   --## _optionals.generate_optional("number")
   --## _optionals.generate_optional("byte")
   --## _optionals.generate_optional("isize")
   --## _optionals.generate_optional("usize")

   ## buildstatus.close 'optionals required'

## local SHOULDTEST = false
## if SHOULDTEST then
   ## buildstatus.open('testing optionals')

   local x: Opt_uinteger

   assert(x.value == 0 and (not x.not_nil), 'test #1 error: x should be {value = 0, not_nil = false}')
   assert(not x:can_get_value(), 'test #2 error: x:can_get_value() should return false')

   -- this will result in a runtime error, I don't know how to test this
   --local y = x:get_value()

   x:set_value(10)

   assert(x.value == 10 and x.not_nil, 'test #3 error: x should be {value = 10, not_nil = true}')
   assert(x.value == x:get_value(), 'test #4 error: x:get_value should returns the x\'s value')
   assert(x:can_get_value(), 'test #5 error: x:can_get_value() should return true')

   ## buildstatus.close('all "optionals" tests succeeded')

## end
