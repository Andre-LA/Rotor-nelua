## if not SYSTEMDATA_ALREADY_REQUIRED then
   ## local SYSTEMDATA_ALREADY_REQUIRED = true

   require 'buildstatus'
   ## buildstatus.open 'requiring system_data'

   require "rotor.bitset_array"
   require "rotor.entity"
   require "rotor.storage"
   require "nstd.nlists.nlinkedlist"

   -- : (a: nLinkedList(BitsetArray), b: nLinkedList(BitsetArray)): nLinkedList(BitsetArray)
   local function union(a: nLinkedList, b: nLinkedList): nLinkedList
      local result = nLinkedList.new()

      for i = 0_u, < a.length do
         local v = (@BitsetArray*)(result:push(#@BitsetArray))
         local a_ptr = (@BitsetArray*)(a:get_data_ptr(i))
         $v = bitset_array.copy($a_ptr)
      end
      for i = 0_u, < b.length do
         local v = (@BitsetArray*)(result:push(#@BitsetArray))
         local b_ptr = (@BitsetArray*)(b:get_data_ptr(i))
         $v = bitset_array.copy($b_ptr)
      end

      return result
   end

   global SystemData = @record{
      mask: BitsetArray,
      mask_write: BitsetArray,
      required_storages: nLinkedList, --nLinkedList(BitsetArray),
      components_indexes: nLinkedList, --nLinkedList(nLinkedList(GenerationalIndex)),
      available_indexes: nLinkedList -- nLinkedList(uinteger)
   }

   -- (read_components: nLinkedList(BitsetArray), write_components: nLinkedList(BitsetArray)): SystemData
   function SystemData.new (read_components: nLinkedList, write_components: nLinkedList): SystemData
      local mask_read = bitset_array.new(1, BITSETARRAY_OF_ZEROS);
      local mask_write = bitset_array.new(1, BITSETARRAY_OF_ZEROS);

      for i = 0_u, < read_components.length do
         local read_component_ptr = (@BitsetArray*)(read_components:get_data_ptr(i))
         mask_read = bitset_array.bor(mask_read, $read_component_ptr)
      end
      for i = 0_u, < write_components.length do
         local write_component_ptr = (@BitsetArray*)(write_components:get_data_ptr(i))
         mask_write = bitset_array.bor(mask_write, $write_component_ptr)
      end

      local new_system_data = (@SystemData){
         mask = bitset_array.bor(mask_read, mask_write),
         mask_write = mask_write,
         required_storages = union(read_components, write_components),
         components_indexes = nLinkedList.new(),
         available_indexes = nLinkedList.new()
      }

      return new_system_data
   end

   local function collect_components (system_data_p: pointer(SystemData), entity_i_p: pointer(Entity)): nLinkedList -- nLinkedList(GenerationalIndex)
      local components_tuple = nLinkedList.new()

      local system_data = $system_data_p
      local entity_i = $entity_i_p

      -- for each required storage, insert the components indexes respectively

      for i = 0_u, < system_data.required_storages.length do
         for j = 0_u, < entity_i.associated_storages.length do
            local entity_i_associated_storages_j_ptr = (@BitsetArray*)(entity_i.associated_storages:get_data_ptr(j))
            local i_required_storages_ptr = (@BitsetArray*)(system_data.required_storages:get_data_ptr(i))

            if bitset_array.equals($i_required_storages_ptr, $entity_i_associated_storages_j_ptr) then
               local entity_i_associated_components_i_ptr = (@GenerationalIndex*)(entity_i.associated_components:get_data_ptr(i))
               local newcomponent_ptr = (@GenerationalIndex*)(components_tuple:push(#@GenerationalIndex))
               local entity_i_associated_components_i: GenerationalIndex = $entity_i_associated_components_i_ptr
               $newcomponent_ptr = entity_i_associated_components_i
               break
            end
         end
      end

      return components_tuple
   end

   function SystemData:update (entities_storage_ptr: pointer(Storage), untracked_ids: nLinkedList--[[(GenerationalIndex)]])
      local entities_storage = $entities_storage_ptr

      for i = 0_u, < untracked_ids.length do
         local entity_id_ptr = (@GenerationalIndex*)(untracked_ids:get_data_ptr(i))
         local entity_id: GenerationalIndex = $entity_id_ptr

         local possible_i_entity = entities_storage:get_entry(entity_id)

         if possible_i_entity:can_get_value() then -- this is a new entity
            local i_entity_ptr = (@Entity*)(possible_i_entity:get_value())
            local i_entity: Entity = $i_entity_ptr

            local masks_intersection = bitset_array.band(i_entity.mask, self.mask)

            if bitset_array.equals(masks_intersection, self.mask) then
               local idx_to_insert: uinteger = 0_u

               local available_indexes_len = self.available_indexes.length
               if available_indexes_len > 0_u then
                  local idx_to_insert_ptr = (@uinteger*)(self.available_indexes:get_data_ptr(available_indexes_len))
                  idx_to_insert = $idx_to_insert_ptr
                  self.available_indexes:pop()
               else
                  idx_to_insert = self.components_indexes.length
               end

               if self.components_indexes:contains(idx_to_insert) then
                  self.components_indexes:remove(idx_to_insert)
               end
               
               local ins_component_idxs = (@nLinkedList*)(self.components_indexes:insert(idx_to_insert, #@nLinkedList))
               $ins_component_idxs = collect_components(self, &i_entity)
            end
         end
      end
   end

   function SystemData:mark_available (idx: uinteger)
      local new_available_idx_ptr = (@uinteger*)(self.available_indexes:push(#@uinteger))
      $new_available_idx_ptr = idx;

      local idx_components_indexes_ptr = (@nLinkedList*)(self.components_indexes:get_data_ptr(idx))
      local idx_components_indexes = $idx_components_indexes_ptr
      idx_components_indexes:clear()
   end

   ## buildstatus.close 'system_data required'
## end
