local ENTITY_COUNT: uinteger <comptime> = 15000_u

require 'math'
require 'os'

require 'buildstatus'
## buildstatus.should_print = false

require ("rotor.bitset_array")
require ("rotor.bitset_array")
require ("rotor.entity")
require ("rotor.storage")
require ("rotor.system_data")

local Vec2 = @record {
   x: integer,
   y: integer
}
function Vec2.new(x: integer, y: integer): Vec2
   return (@Vec2){x = x, y = y}
end

global Position: type = @Vec2
global Velocity: type = @Vec2
global Name: type = @string

local Rightmost = @record {
   pos_component: Position,
   name_component: Name
}

local Storages = @record {
   position: Storage,
   velocity: Storage,
   entity: Storage,
   name: Storage
}

-- storages, its where components and entities will live
local storages = (@Storages) {
   position = Storage.new(),
   velocity = Storage.new(),
   entity = Storage.new(),
   name = Storage.new()
}

local Masks = @record{
   position: BitsetArray,
   velocity: BitsetArray,
   name: BitsetArray
}

-- masks
local masks: Masks = (@Masks){
   position = bitset_array.new(1, BITSETARRAY_OF_ONE),                         -- 1
   velocity = bitset_array.lshift(bitset_array.new(1, BITSETARRAY_OF_ONE), 1), -- 2
   name     = bitset_array.lshift(bitset_array.new(1, BITSETARRAY_OF_ONE), 2)  -- 4
}

local movement_read: nLinkedList = nLinkedList.new() --nLinkedList(BitsetArray)
do
   local movement_read1_ptr = (@BitsetArray*)(movement_read:push(#@BitsetArray))
   $movement_read1_ptr = bitset_array.copy(masks.velocity)
end

local movement_write: nLinkedList = nLinkedList.new() --nLinkedList(BitsetArray)
do
   local movement_write1_ptr = (@BitsetArray*)(movement_write:push(#@BitsetArray))
   $movement_write1_ptr = bitset_array.copy(masks.position)
end

local rightmost_read: nLinkedList = nLinkedList.new() --nLinkedList(BitsetArray)
do
   local rightmost_read1_ptr = (@BitsetArray*)(rightmost_read:push(#@BitsetArray))
   $rightmost_read1_ptr = bitset_array.copy(masks.name)

   local rightmost_read2_ptr = (@BitsetArray*)(rightmost_read:push(#@BitsetArray))
   $rightmost_read2_ptr = bitset_array.copy(masks.position)
end

local rightmost_write: nLinkedList = nLinkedList.new() --nLinkedList(BitsetArray)

-- systems data
local SystemsData = @record{
   movement: SystemData,
   rightmost: SystemData
}

local systems_data = (@SystemsData){
   movement  = SystemData.new(movement_read, movement_write),
   rightmost = SystemData.new(rightmost_read, rightmost_write)
}
-- systems are just functions, here we have 2 examples
-- movement_system is more "functional", using arguments instead of locals declared above.
-- rightmost_system will use the locals
-- anyway, do what you think is better, is just a function ;)

local function movement_system(mov_system_data: SystemData, velocity_storage: Storage, position_storage: Storage)
   for i = 0_u, < mov_system_data.components_indexes.length do
      local ids_ptr = (@nLinkedList*)(mov_system_data.components_indexes:get_data_ptr(i))
      local ids = $ids_ptr

      if ids.length > 0 then
         local vel_id_ptr = (@GenerationalIndex*)(ids:get_data_ptr(0))
         local pos_id_ptr = (@GenerationalIndex*)(ids:get_data_ptr(1))

         local vel_id: GenerationalIndex = $vel_id_ptr
         local pos_id: GenerationalIndex = $pos_id_ptr

         local possible_vel = velocity_storage:get_entry(vel_id)
         local possible_pos = position_storage:get_entry(pos_id)

         if possible_pos:can_get_value() and possible_vel:can_get_value() then
            local pos_ptr = (@Velocity*)(possible_pos:get_value())
            local vel_ptr = (@Position*)(possible_vel:get_value())

            local pos = $pos_ptr
            local vel = $vel_ptr

            pos.x = pos.x + vel.x
            pos.y = pos.y + vel.y

            $pos_ptr = pos
            $vel_ptr = vel
         else
            mov_system_data:mark_available(i)
         end
      end
   end
end

local function rightmost_system(rightmost_ptr: pointer(Rightmost))
   local rightmost = $rightmost_ptr
   local rightmost_position = -99999999

   for i = 0_u, < systems_data.rightmost.components_indexes.length do
      local ids_ptr = (@nLinkedList*)(systems_data.rightmost.components_indexes:get_data_ptr(i))
      local ids = $ids_ptr

      if ids.length > 0 then
         local name_id_ptr = (@GenerationalIndex*)(ids:get_data_ptr(0))
         local pos_id_ptr = (@GenerationalIndex*)(ids:get_data_ptr(1))

         local name_id: GenerationalIndex = $name_id_ptr
         local pos_id: GenerationalIndex = $pos_id_ptr

         local possible_name = storages.name:get_entry(name_id)
         local possible_pos  = storages.position:get_entry(pos_id)

         if possible_name:can_get_value() and possible_pos:can_get_value() then
            local name_ptr = (@Name*)(possible_name:get_value())
            local pos_ptr = (@Position*)(possible_pos:get_value())

            local name = $name_ptr
            local pos = $pos_ptr

            if pos.x > rightmost_position then
               rightmost_position  = pos.x
               rightmost.pos_component  = pos
               rightmost.name_component = name
            end
         else
            systems_data.rightmost:mark_available(i)
         end
      end
   end

   $rightmost_ptr = rightmost
end

-- here, we will store the ids
local e_ids: nLinkedList --(GenerationalIndex);
local names_ids: nLinkedList --(GenerationalIndex);

-- also, we need to store the ids of created and removed entities ids
local untracked_entities_ids: nLinkedList -- GenerationalIndex

-- let's create 1 entity!
print 'creating!'
for i = 0_u, < ENTITY_COUNT do
   -- create an entity in the entities storage and get this new entity
   local new_entity_pptr, new_entity_id = storages.entity:new_entry(#@Entity)
   local new_entity_ptr = (@Entity*)(new_entity_pptr)

   local new_entity = Entity.new()


   local e_id_ptr = (@GenerationalIndex*)(e_ids:push(#@GenerationalIndex))
   $e_id_ptr = new_entity_id


   -- create the components in their respective storages.
   -- storage.new_entry(value) returns a generational_index, it's used as an ID
   -- create_position(x, y) returns just a new very simple table, remember?
   local new_position_pptr, new_position_id = storages.position:new_entry(#@Position)
   local new_velocity_pptr, new_velocity_id = storages.velocity:new_entry(#@Velocity)
   local new_name_pptr, new_name_id = storages.name:new_entry(#@Name)

   local new_position_ptr = (@Position*)(new_position_pptr)
   local new_velocity_ptr = (@Velocity*)(new_velocity_pptr)
   local new_name_ptr = (@Name*)(new_name_pptr)

   math.randomseed(os.time_default())
   $new_position_ptr = (@Position){x = (@integer)(math.random() * 200 - 100.0), y = (@integer)(i)}
   math.randomseed(os.time_default())
   $new_velocity_ptr = (@Velocity){x = (@integer)(math.random() * 400 - 200.0), y = 0}
   $new_name_ptr = "some entity"

   -- storages accepts any value
   local names_id_ptr = (@GenerationalIndex*)(names_ids:push(#@GenerationalIndex))
   $names_id_ptr = new_name_id

   -- this is how we associate an entity with a storage entry;
   -- making a unique bitmask per storage is necessary
   new_entity:associate(new_position_id, masks.position)

   new_entity:associate(new_velocity_id, masks.velocity)

   new_entity:associate(new_name_id, masks.name)

   $new_entity_ptr = new_entity


   -- storing the new entity ids
   local untracked_entities_ids_ptr = (@GenerationalIndex*)(untracked_entities_ids:push(#@GenerationalIndex))
   $untracked_entities_ids_ptr = new_entity_id
end

-- now, we update the systems datas, so they will know what entities
-- should be processed
print 'update systems!'
systems_data.movement:update(&storages.entity, untracked_entities_ids)
systems_data.rightmost:update(&storages.entity, untracked_entities_ids)

 --let's execute movement system 10x
for _ = 1, 10 do
   print ('executing movement system')
   movement_system(systems_data.movement, storages.velocity, storages.position)
end

local rightmost: Rightmost

-- let's execute rightmost_system, note that 'rigtmost' variable
-- is not an storage, component, or something specific;
-- since systems are just functions that you can declare and use
-- in whathever way you want, there is absolutely no special thing
-- in executing systems, they are just functions.
print ('executing rightmost system')
rightmost_system(&rightmost)

for i: uinteger = 0_u, < storages.entity.entries.length do
   local e_id_ptr = (@GenerationalIndex*)(e_ids:get_data_ptr(i))
   local e_id: GenerationalIndex = $e_id_ptr

   local name_id_ptr = (@GenerationalIndex*)(names_ids:get_data_ptr(i))
   local name_id: GenerationalIndex = $name_id_ptr

   local possible_e_ptr: Opt_pointer = storages.entity:get_entry(e_id)

   if possible_e_ptr:can_get_value() then
      local e_ptr = (@Entity*)(possible_e_ptr:get_value())
      local e: Entity = $e_ptr

      e:disassociate_by_storage(masks.position)
      e:disassociate_by_storage(masks.velocity)
      e:disassociate_by_component(name_id)
   end
end

local name, pos_x = rightmost.name_component, rightmost.pos_component.x
print ("entity '", name, "' is in the rightmost position x: ", pos_x)

--[==[
--]==]
